import gzip 

def f_gzip_extract_reads(filename):
    """ Opening a gzip file and extracting the reads"""
    print("Current function f_gzip_extract_reads")
    reads_list = []
    line_count = 2
    with gzip.open(filename, 'rt') as f:
            for line in f:
                line_count += 1        
                if line_count % 4 == 0:                                         # grab the sequence line
                    read_seq = line.rstrip()
                    reads_list.append(read_seq)
                if line_count % 1000000 == 0:                                   # Counter
                    print("Current line being read: ",line_count)
    f.close()
    print("f_gzip_extract_reads of %s is complete!"  %filename)
    return reads_list

def f_ResGeneDict_Kmers(infile):
    """ Create a dictionary of all resistace genes (keys) and their sequences (values,
    and a nested dictionary of positions (keys) and counts (as values)"""
    print("Current function f_ResGeneDict")
    ### Needs a TRY statement_________________________________________________
    
    # Kmer creation from Resistance Genes file
    ResFile = open(infile, "r")
    ### _____________________________________________________________________
    
    info = [] # info line
    ResGene_Dict = {}
    data = ''    
    for line in ResFile:                                                        # When ">" , assemble the sequence
        if line.startswith('>'):                                                # Read Line by line
            if data:   # push to seqs
                ResGene_Dict[info] = {}
                ResGene_Dict[info][data]= {}
                for i in f_kmer_generator(data, 19):
                    ResGene_Dict[info][data][i]=0
                data = ''
            info = line[:-1]           
        else:
            data += line.strip()                                                                                     
    ResGene_Dict[info] = {}                                                     # Last entry push
    ResGene_Dict[info][data]= {}
    for i in f_kmer_generator(data, 19):
        ResGene_Dict[info][data][i]=0
    print("f_ResGeneDict_Kmers of %s is complete!" % infile) 
    return ResGene_Dict

def f_Kmer_depth(Reads_list,min_depth):
    """ Create all kmers from reads and subselect 
    for the depth(aka number of occurance"""
    print("Curent function f_Kmer_depth")
    test_counter=0    
    Kmer_Dict = dict()
    for read in Reads_list:
        test_counter +=1
        kmer_list = f_kmer_generator(read,19)
        for kmer in kmer_list:
            if kmer in Kmer_Dict:                                               # Kmer count
                Kmer_Dict[kmer] += 1
            else:
                Kmer_Dict[kmer] = 1
        if test_counter%100000 ==0:                                             # Counter
            print("f_Kmer_depth, counter state: ", test_counter )
            
def f_Kmer_depth_rev_com(Reads_list,min_depth):
    """ Create all kmers from reads and subselect 
    for the depth(aka number of occurance"""
    print("Curent function f_Kmer_depth")
    test_counter=0    
    Kmer_Dict = dict()
    for read in Reads_list:
        test_counter +=1
        
        kmer_list = f_kmer_generator(read,19)
        rev_read = reverse_complement(read)                                       # Reverse complement the sequence 
        rev_kmer_list = f_kmer_generator(rev_read,19)
        kmer_list.extend(rev_kmer_list)
        for kmer in kmer_list:
            if kmer in Kmer_Dict:
                Kmer_Dict[kmer] += 1
            else:
                Kmer_Dict[kmer] = 1
        if test_counter%100000 ==0:
            print("f_Kmer_depth, counter state: ", test_counter ) 
    Reads_subset = {key:val for key, val in Kmer_Dict.items() if val > min_depth} # Create a subset based on depth specifications
    print("Done") 
    return Reads_subset, Kmer_Dict # this can be removed if we choose to subselect (will free up the memory )
 ### currently with these files it is .... 123 445 562 kmers in total, subset is 11 138 671 (x100 less if cut to min depth 10)
    

def f_kmer_generator(sequence, kmer_length):
    """k-mer generator using list"""
    kmer_list = list()
    for i in range(0, len(sequence)-kmer_length+1):
        kmer_list.append(sequence[i:i+kmer_length])
    return(kmer_list)
    
def reverse_complement(DNA_sequence):
    """Reverse complement a given DNA sequence"""
    DNA_translation_table = str.maketrans("ACGT", "TGCA")
    rev_compliment = DNA_sequence.translate(DNA_translation_table)
    return rev_compliment[::-1]    


    
def f_Dict_crosscheck2(newRes_Dict, Reads_subset):
    ### So here i can quickly check for the presence of the kmers in both dics
    ### If we construct a loop to go over each kmer for reference gene in turn and if complete
    ### create a file with the gene ID , coverage depth value ( which is set for the subselection)
    ### That could be a good output as a start??? 
    
    """ Cross check reads and resistance genes dictionaries, 
    check if the kmers are present in both and assign the count from 
    the reads dictionary"""
    results = []
    try: 
        gene_counter = 0
        #inner = 0
        

        for key1 in newRes_Dict:                                                 # for ID
            gene_counter +=1
            for key2 in newRes_Dict[key1]:                                       # for Sequence
                kmer_count = 0                                                   # how many kmers has been matched
                seq_len = len(key2)-18                                           # how many kmers per gene (Seq_len - kmer_size_len+1 (0-indexing))
                min_depth = None
                for key3 in newRes_Dict[key1][key2]:                             # the inner key aka kmers
                    #inner += 1
                    if key3 in Reads_subset:
                        kmer_count +=1                                           # if kmer matched +=1
                        newRes_Dict[key1][key2][key3]=Reads_subset[key3]
                        if min_depth is None or Reads_subset[key3] < min_depth:
                            min_depth = Reads_subset[key3]
                gene_coverage = int(kmer_count*100/seq_len)  
                if gene_coverage >=95:
                    print("%s : \nCoverage of %s %% and minimum depth of %s\n" % (key1,gene_coverage, min_depth))
                    results.append((key1,gene_coverage, min_depth))
            if gene_counter % 100 == 0:
                print("Number of genes processed: ",gene_counter)
    except TypeError as e:
        print(e)        
        print(key1, key2, key3,)

    return results  

