#!/usr/bin/env python3
import time
import sys
import gzip



def f_kmer_generator(Dict, sequence, kmer_length):
    """k-mer generator that appends the kmers immediately to hte dictionary
    has been tested and shown to be faster than generating lists 
    which are then processed into a Dict"""
    for i in range(0, len(sequence)-kmer_length+1):
        kmer = sequence[i:i+kmer_length]
        if kmer in Dict:                                   # Kmer count
            Dict[kmer] += 1
        else:
            Dict[kmer] = 1
def f_kmer_generator_ResGen(sequence, kmer_length):
    """k-mer generator for the Resistance gene file
    (slight iteration compared to the other function)"""
    kmer_list = list()
    for i in range(0, len(sequence)-kmer_length+1):
        kmer_list.append(sequence[i:i+kmer_length])
    return(kmer_list)
    
def reverse_complement(DNA_sequence):
    """Reverse complement a given DNA sequence"""
    DNA_translation_table = str.maketrans("ACGT", "TGCA")
    rev_compliment = DNA_sequence.translate(DNA_translation_table)
    return rev_compliment[::-1]  

def f_gzip_extract_reads(filename1, filename2):
    """ Opening a gzip file and extracting the reads"""
    print("Initialized: sequence exraction from files <%s , %s>" %(filename1,filename2))
    Kmer_Dict = dict() # TRy DICT from teh start
    seq_counter=0 
    line_count=2
    with gzip.open(filename1, 'rt') as f1, gzip.open(filename2, "rt") as  f2:
        while True:
            
            line_1 = f1.readline()
            line_2 = f2.readline()
            line_count += 1        
            if line_count % 4 == 0:                                             # grab the sequence line
                
                read1 = line_1.rstrip()
                read2 = line_2.rstrip()
                
                read_reverse1 = reverse_complement(read1)  
                read_reverse2 = reverse_complement(read2)     
                       
                f_kmer_generator(Kmer_Dict, read1,19)
                f_kmer_generator(Kmer_Dict, read2,19)
                
                f_kmer_generator(Kmer_Dict, read_reverse1,19)
                f_kmer_generator(Kmer_Dict, read_reverse2,19)
                
            if (line_count-2)*2 % 1000000== 0:                                      # Counter , two files, started from 2
                print("# of reads processed: ",(line_count-2)*2) 
                
            if not line_1 and not line_2:
                break     

    f1.close()
    f2.close()
    Kmer_Dict = {key:val for key, val in Kmer_Dict.items() if val >= 10}
    print("Reading of the following files is complete! \n %s \n %s"  % (infile_read1, infile_read2))
    return Kmer_Dict

def f_ResGeneDict_Kmers(infile):
    """ Create a dictionary of all resistace genes (keys) and their sequences (values,
    and a nested dictionary of positions (keys) and counts (as values)"""
    print("Loading the Resistance Genes from <%s> file" %infile)
    ### Needs a TRY statement_________________________________________________
    
    # Kmer creation from Resistance Genes file
    ResFile = open(infile, "r")
    ### _____________________________________________________________________
    
    info = [] # info line
    ResGene_Dict = {}
    data = ''    
    for line in ResFile:                                                        # When ">" , assemble the sequence
        if line.startswith('>'):                                                # Read Line by line
            if data:   # push to seqs
                ResGene_Dict[info] = {}
                ResGene_Dict[info][data]= {}
                for i in f_kmer_generator_ResGen(data, 19):
                    ResGene_Dict[info][data][i]=0
                data = ''
            info = line[:-1]           
        else:
            data += line.strip()                                                                                     
    ResGene_Dict[info] = {}                                                     # Last entry push
    ResGene_Dict[info][data]= {}
    for i in f_kmer_generator_ResGen(data, 19):
        ResGene_Dict[info][data][i]=0
    print("Resistance Gene file <%s> loading is  complete!" % infile) 
    return ResGene_Dict

def f_Dict_crosscheck2(ResGene_Dict, Reads_Dict):
    ### So here i can quickly check for the presence of the kmers in both dics
    ### If we construct a loop to go over each kmer for reference gene in turn and if complete
    ### create a file with the gene ID , coverage depth value ( which is set for the subselection)
    ### That could be a good output as a start??? 
    
    """ Cross check reads and resistance genes dictionaries, 
    check if the kmers are present in both and assign the count from 
    the reads dictionary"""
    results = []
    try: 
        gene_counter = 0
        #inner = 0
        

        for key1 in ResGene_Dict:                                                 # for ID
            gene_counter +=1
            
            for key2 in ResGene_Dict[key1]:                                       # for Sequence
                kmer_count = 0                                                   # how many kmers has been matched
                seq_len = len(key2)-18                                           # how many kmers per gene (Seq_len - kmer_size_len+1 (0-indexing))
                min_depth = None
                
                for key3 in ResGene_Dict[key1][key2]:                             # the inner key aka kmers
                    if key3 in Reads_Dict:
                        kmer_count +=1                                           # if kmer matched +=1
                        ResGene_Dict[key1][key2][key3]=Reads_Dict[key3]
                        if min_depth is None or Reads_Dict[key3] < min_depth:
                            min_depth = Reads_Dict[key3]
                gene_coverage = int(kmer_count*100/seq_len)  
                if gene_coverage >=95:
                    print("%s : \nCoverage of %s %% and minimum depth of %s\n" % (key1,gene_coverage, min_depth))
                    results.append((key1,gene_coverage, min_depth))
            if gene_counter % 100 == 0:
                print("Number of genes processed: ",gene_counter)
    except TypeError as e:
        print(e)        
    return results  


# Write the results
def f_write_results(results):
    outfile = open("results.txt", "w")
    results.sort(reverse = True,key=lambda x: (x[1], x[2]))
    for i in range(len(results)):
        print("{:.2f}\t\t{:.2f}\t\t{}".format(results[i][1], results[i][2], results[i][0]), file = outfile)
    print("Processing time elapsed :",int((end-start)/60), "min", file = outfile)
    outfile.close() 
    
    

infile_read1 = "file1.txt.gz"
infile_read2 = "file2.txt.gz"
infile_res = "resistance_genes.fsa"

start = time.time() # time measurement



try:
    # Read the resistance reference genes
    Kmer_Dict = f_gzip_extract_reads(infile_read1,infile_read2)
    end = time.time()
    print("Processing time elapsed :",int((end-start)/60), "min")    
    Res_Dict = f_ResGeneDict_Kmers(infile_res)
    
except IOError as e:
    print(e)
    sys.exit(1) 
try:
    results = f_Dict_crosscheck2(Res_Dict, Kmer_Dict)
except TypeError as e:
    print(e)
end = time.time()

f_write_results(results)
   

print("Processing time elapsed :",int((end-start)/60), "min")



  

    
